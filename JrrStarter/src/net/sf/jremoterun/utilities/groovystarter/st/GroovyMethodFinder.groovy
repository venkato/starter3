package net.sf.jremoterun.utilities.groovystarter.st

import groovy.transform.CompileStatic
import net.sf.jremoterun.utilities.JrrClassUtils2
import net.sf.jremoterun.utilities.groovystarter.ConsoleSymbols
import net.sf.jremoterun.utilities.groovystarter.st.str2obj.StringToObjectConverter

import java.lang.reflect.Field
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method
import java.lang.reflect.Type
import java.util.logging.Logger

@CompileStatic
public class GroovyMethodFinder {

    private static final Logger log = Logger.getLogger(GroovyMethodFinder.getName());


    public List<String> autoGeneratedGroovyMethodNames = (List) [
            "methodMissing", "propertyMissing",
            "getProperty", "invokeMethod", "setProperty",]
//            .collect { it.methods.collect { Method m -> m.name } }.flatten()

    Method findMethod(Object onObject, List<String> args) throws GroovyMethodFinderException {
        List<Method> methods0 = findAvailableMethods(onObject, true);
        boolean errorFound = false;
        PrintSelfHelp printSelfHelp = null
        if (onObject instanceof PrintSelfHelp) {
            printSelfHelp = onObject as PrintSelfHelp;
        }
        boolean printMethods = args.size() == 0 || args[0] == ConsoleSymbols.question.s
        if (printMethods) {
            if (printSelfHelp != null) {
                printSelfHelp.onMethodNotFound();
            }
            List<Method> methods1 = findAvailableMethods(onObject, false);
            String msg = """specify method
    available : ${convertMethodsNamesToString(methods1)}"""
            throw new GroovyMethodFinderException(msg);
        }

        String methodName = args[0];
        log.fine " running method : ${methodName}"
        List<String> args2 = new ArrayList(args);
        args2.remove(0);
        List<Method> methods = methods0.findAll { it.name == methodName };
        if (methods.size() == 0) {
            errorFound = true
            if (printSelfHelp != null) {
                printSelfHelp.onMethodNotFound();
            }
            List<Method> methods1 = findAvailableMethods(onObject, false);
            String msg
            if (methods1.size() == 0) {
                msg = "wrong method ${methodName}, no public method available"
            } else {
                msg = "wrong method ${methodName}, available : " + convertMethodsNamesToString(methods1)
            }
            throw new GroovyMethodFinderException(msg);

        }
        boolean printMethodsArgs = args2[0] == ConsoleSymbols.question.s
        if (printMethodsArgs) {
            errorFound = true
            if (printSelfHelp != null) {
                printSelfHelp.onMethodNotFound();
            }
            String msg = """found ${methods.size()} methods '${methodName}' : 
"""
            msg += getMethodsDescription(methods)
            throw new GroovyMethodFinderException(msg);
        }
        List<Method> methods2 = methods.findAll { it.parameterTypes.length == args2.size() }
        if (methods2.size() > 1) {
            errorFound = true
            if (printSelfHelp != null) {
                printSelfHelp.onMethodNotFound();
            }

            String msg = """found ${methods2.size()} methods '${methodName}' with the same arguments count: 
"""
            msg += getMethodsDescription(methods)
            throw new GroovyMethodFinderException(msg);
        }
        if (methods2.size() == 0) {
            errorFound = true
            if (printSelfHelp != null) {
                printSelfHelp.onMethodNotFound();
            }
            String msg = """wrong method ${methodName} arguments count, got : ${args2.size()}, available : 
"""
            msg += getMethodsDescription(methods)
            throw new GroovyMethodFinderException(msg);
        }
        Method method = methods2[0]
        return method

    }

    String getMethodsDescription(List<Method> methods) {
        String msg = methods.collect {
            '(' + it.parameterTypes.collect { Class br -> br.simpleName }.join(',') + ')'
        }.sort().join(';\n')
        return msg
    }

    List<Method> getMethodsForClass(Class thisClazz) {
        return thisClazz.getMethods().toList()
    }


    List<Method> findAvailableMethods(Object onObject, boolean includeGettersSetters) {
        List<String> fieldNames = []
        if (!includeGettersSetters) {
            JrrClassUtils2.fieldsIterator(onObject.class, { Field f ->
                fieldNames.add(f.name.toLowerCase())
                return false
            })
        }
        Class thisClazz = onObject.class;
        List<Method> methods0 = getMethodsForClass(thisClazz)
                .findAll { it.declaringClass != groovy.lang.GroovyObject }
                .findAll { it.declaringClass != groovy.lang.Script }
                .findAll { it.declaringClass != java.lang.Object }
                .findAll { it.declaringClass != org.codehaus.groovy.reflection.CachedClass }
                .findAll { !autoGeneratedGroovyMethodNames.contains(it.name) }
        if (!includeGettersSetters) {
            methods0 = methods0.findAll { !(it.name == "main" && it.parameterTypes.length == 1) }
                    .findAll { !it.name.startsWith('_') }
                    .findAll { !it.name.contains('$') }
                    .findAll { !it.declaringClass.name.startsWith('junit.framework.') }

            methods0 = methods0.findAll { Method m ->
                if (m.name.length() < 4) {
                    return true
                }
                String lowCase = m.name.substring(3).toLowerCase()
                boolean pass = !fieldNames.contains(lowCase)
                return pass
            }
        }
        return methods0;
    }

    String convertMethodsNamesToString(List<Method> methods0) {
        return methods0.collect { it.name }.unique().sort().join(',')
    }


    Object runMethod(Object onObject, List<String> args) throws GroovyMethodFinderException {
        Method method;
        try {
            method = findMethod(onObject, args)
        } catch (GroovyMethodFinderException e) {
//            println("arh size ${args.size()} , ${args}")
            if (args.size() == 0) {
                if(onObject==null){
                    log.severe("object is null, ${args}")
                }else {
                    String name34 = onObject.getClass().getName()
                    try {
                        if (onObject instanceof Script) {
                            Script script = onObject as Script
                            return script.run()
                        }
                        if (onObject instanceof Runnable) {
                            Runnable runnable = (Runnable) onObject
                            runnable.run()
                            return null;
                        }
                    } catch (NullPointerException e2) {
                        log.info "failed invoke ${name34} : ${e2}"
                        throw e2
                    }
                }
            }
            throw e;

        }
        List<String> args2 = new ArrayList(args);
        args2.remove(0);
        List args3 = parseArgs(args2, method);
        try {
            Object res = method.invoke(onObject, args3.toArray())
            log.fine "finished ok"
            return res;
        } catch (InvocationTargetException e) {
            Throwable e2 = e.getCause()
            if (e2 == null) {
                throw e
            }
            throw e2
        }
    }


    List parseArgs(List<String> args2, Method method) {
        Type[] genericParameterTypes = method.getGenericParameterTypes()
        List<Class> paramTypes = (List) method.parameterTypes.toList()
        int i = 0
        List args3 = paramTypes.collect {
            String arg = args2[i]
            Type genericArg
            Class paramType = paramTypes[i]
            if (genericParameterTypes.length > 0) {
                genericArg = genericParameterTypes[i]
            }
            Object param = StringToObjectConverter.defaultConverter.convertFromStringToType(arg, paramType, genericArg)
            i++
            return param

        }
        return args3
    }


}